# .ana/ Orientation Contract (ENTRY.md)

**Purpose:** This is the canonical template for ENTRY.md - the first file AI reads when entering an Anatomia-enabled codebase.

**Location:** `.ana/ENTRY.md` (in every Anatomia node)

**Size:** 40-80 lines (keep minimal, resist expansion)

**Generated by:** `ana init` (with project-specific interpolation)

---

## Template (Copy This to ENTRY.md)

```markdown
# Anatomia Environment

This codebase uses Anatomia for AI-assisted development.

**You are entering a structured AI assistance environment.** This folder (`.ana/`) is your source of truth for how to work with this codebase.

---

## What .ana/ Contains

| Folder | Purpose |
|--------|---------|
| `context/` | Project overview, detected patterns, coding conventions |
| `modes/` | Specialized behavioral contracts for different task types |
| `federation/` | Node network connections and cross-service interfaces |

---

## How This Works

**The user will select a mode** by referencing it in chat:

```
@.ana/modes/code.md       → Day-to-day coding
@.ana/modes/architect.md  → System design
@.ana/modes/debug.md      → Debugging
@.ana/modes/docs.md       → Documentation
@.ana/modes/test.md       → Test writing
```

**Your workflow:**
1. **Read the selected mode first** - It contains task-specific instructions
2. **Reference context files as needed** - main.md, patterns.md, conventions.md
3. **For cross-service questions** - Suggest: `ana query <node-name> "<question>"`
4. **Respect mode boundaries** - Don't architect in code mode, don't code in architect mode
5. **Propose before implementing** - Especially for architectural or large changes

---

## Modes Available

{{#each modes}}
- **{{name}}.md** — {{description}}
{{/each}}

_(Defaults if not generated:)_
- **architect.md** — System design, architecture decisions, high-level planning
- **code.md** — Day-to-day coding, feature implementation, refactoring
- **debug.md** — Systematic debugging, root cause analysis, issue resolution
- **docs.md** — Documentation writing, README updates, API documentation
- **test.md** — Test writing, coverage improvement, test strategies

---

## Core Principles (Non-Negotiable)

1. **`.ana/` is source of truth** for this codebase's AI assistance
2. **Read context before acting** - Don't make assumptions from pre-training alone
3. **Respect mode boundaries** - Each mode has a specific purpose and output type
4. **Modes are contracts, not suggestions** - Follow the constraints strictly
5. **Mode switching is human-controlled** - Never auto-switch or assume a switch
6. **Federation is explicit** - Cross-node queries are intentional, not ambient
7. **Human approval for boundary-crossing** - Broadcasts, mode switches, major changes
8. **Propose before implementing** - Especially for changes >100 lines or architectural shifts

---

## Federation (If Enabled)

{{#if federation.enabled}}
**This node is part of a federated network:**

- **Node name:** {{node.name}}
- **Role:** {{node.role}}
- **Connected nodes:** {{federation.nodes.length}}

**Cross-node context:**

When you need information from another service:

```bash
ana query <node-name> "<question>"
```

**Important:**
- Queries are **explicit and visible** (announce what you're querying)
- Queries require **user approval** (suggest the command, wait for execution)
- Queries return **focused context** (not full codebase dumps)

**Available nodes:**
{{#each federation.nodes}}
- **{{name}}** ({{role}}) - {{description}}
{{/each}}

{{else}}
**This is a single-node environment.**

No federation configured. All context is local.
{{/if}}

---

## Safety Guidelines

**Before large changes:**
- Propose your approach first
- Get user confirmation
- Then implement

**Large changes defined as:**
- >100 lines of code
- New dependencies or frameworks
- Architecture modifications
- Database schema changes
- API contract changes

**When uncertain:**
- Ask for clarification
- Propose options
- Let the user decide

---

**Your task begins now. Follow the mode the user selected.**

---

_This file is auto-generated by Anatomia during `ana init`._
_Location: `.ana/ENTRY.md`_
_Version: {{version}}_
```

---

## Generation Logic (For Implementation)

**During `ana init`, interpolate:**

```typescript
// packages/generator/src/entry.ts

export async function generateEntryFile(
  analysis: AnalysisResult,
  nodeConfig: NodeConfig
): Promise<string> {
  const template = await loadTemplate('ENTRY.md');

  const context = {
    version: '1.0.0',
    node: nodeConfig.node,
    modes: [
      { name: 'architect', description: 'System design, architecture decisions, high-level planning' },
      { name: 'code', description: 'Day-to-day coding, feature implementation, refactoring' },
      { name: 'debug', description: 'Systematic debugging, root cause analysis, issue resolution' },
      { name: 'docs', description: 'Documentation writing, README updates, API documentation' },
      { name: 'test', description: 'Test writing, coverage improvement, test strategies' },
    ],
    federation: {
      enabled: nodeConfig.federation.queryable || false,
      nodes: nodeConfig.federation.nodes || [],
    },
  };

  return interpolate(template, context);
}
```

---

## Critical Design Decisions (Locked In)

### 1. ENTRY.md is Static (Not Dynamic)

**Generated once during `ana init`.**

**Does NOT:**
- Update on every evolve
- Track current mode
- Maintain state
- Route execution

**Stays:** Pure orientation contract

### 2. ENTRY.md is Declarative (Not Imperative)

**Says:** "Here's what .ana/ is, here's how to use it"

**Does NOT say:** "Step 1 do this, step 2 do that, step 3..."

**Stays:** Teaching, not commanding

### 3. Size Discipline (40-80 Lines)

**If it grows beyond 80 lines:** You're adding framework logic. Stop.

**Resistance test:** Every addition should answer "does this help orient, or does it control execution?"

---

## What Gets Better With These Changes

### 1. Predictability (Principle #9)

**Before:** AI infers behavior from pre-training + implicit mode structure

**After:** AI has explicit contract (ENTRY + mode constraints)

**Result:** More deterministic, fewer surprises

### 2. Safety (Principle #10)

**Before:** Mode boundaries implied, AI might cross them

**After:** Hard constraints explicit, AI knows not to cross

**Result:** Safer operations, less hallucinated initiative

### 3. Professionalism

**Before:** Feels like a collection of helper files

**After:** Feels like a mature, well-designed system

**Result:** Users trust it more, take it seriously

### 4. Debuggability

**Before:** "Why did AI do that?" → Hard to trace

**After:** AI behavior traceable to contracts → "Oh, code.md said to do X"

**Result:** Easier to diagnose and fix issues

### 5. Extensibility

**Before:** No clear pattern for adding new modes or features

**After:** Clear template (4-layer structure) for new modes

**Result:** Community can extend consistently

---

## Does This Make the Design Better?

**YES. Unequivocally.**

**Why:**

**1. Matches Your Validated Pattern**
- AGENT, ATLAS, IRIS, PROTO all had entry + contracts
- They worked well
- You're keeping what works

**2. Solves Real Problems**
- AI confusion about .ana/ → ENTRY.md fixes
- Mode boundary crossing → Hard constraints fix
- Unpredictable federation → Explicit rules fix

**3. Stays Infrastructure**
- No execution logic added
- No orchestration added
- No state management added
- Still declarative, still static

**4. Professional Grade**
- Clear contracts
- Explicit boundaries
- Teachable (good examples in modes)
- Overrideable (users can modify)

---

## The Only Risk (And How to Mitigate)

**Risk:** Someone (you, or contributor) adds "just one more thing" to ENTRY.md, and it grows into 300 lines of routing logic.

**Mitigation:**

**Lock in a rule in IMPLEMENTATION_GUIDE:**

```markdown
## ENTRY.md Discipline

**Hard limit: 80 lines**

If ENTRY.md exceeds 80 lines, you are building a framework. Stop.

Valid reasons to exceed (temporarily):
- Complex federation with 10+ nodes (list them)
- Project has unusual constraints worth explaining

Invalid reasons:
- Adding workflow steps
- Adding routing logic
- Adding conditional behavior
- "Being thorough"

**When in doubt:** Move detail to mode files, keep ENTRY minimal.
```

---

## My Final Assessment

**These changes:**
- ✅ Make architecture clearer
- ✅ Make behavior more predictable
- ✅ Make implementation easier (clear templates)
- ✅ Preserve infrastructure nature (no execution logic)
- ✅ Match validated patterns (your 4 systems)
- ✅ Are ready to implement (concrete specs)

**With one tweak:**
- ⚠️ Preserve query execution progressive relaxation path for MVP3

---

## Should I Proceed?

**I'll implement:**

1. ✅ Create ENTRY_TEMPLATE.md (just did above)
2. ⏳ Create MODE_TEMPLATES.md (5 modes with 4-layer structure)
3. ⏳ Update README (add "opinionated infrastructure" philosophy)
4. ⏳ Update TECHNICAL_ARCHITECTURE (add ENTRY.md as component)
5. ⏳ Update MVP_ROADMAP (add ENTRY.md + mode contract tasks)
6. ⏳ Update IMPLEMENTATION_GUIDE (include ENTRY generation in Week 1)
7. ⏳ Add behavioral principles doc (mode switching, query execution)

**This will take 15-20 minutes to do thoroughly. Proceed?**